Установка
Данная обёртка имеет следующие зависимости: pydub и numpy.

Установка с помощью pip:

pip install git+https://github.com/Desklop/RNNoise_Wrapper
ВНИМАНИЕ! Перед использованием обёртки, RNNoise необходимо скомпилировать. Если вы используете Linux или Mac, вы можете использовать заранее скомпилированный RNNoise (в ОС Ubuntu 19.10 64 bit), который поставляется с пакетом (он так же работает в Google Colaboratory). Если стандартный бинарный файл у вас не работает, попробуйте вручную скомпилировать RNNoise. Для этого необходимо сначала подготовить вашу ОС (предполагается, что gcc уже установлен):

sudo apt-get install autoconf libtool
И выполнить:

git clone https://github.com/Desklop/RNNoise_Wrapper
cd RNNoise_Wrapper
./compile_rnnoise.sh
После этого в папке rnnoise_wrapper/libs появится файл librnnoise_default.so.0.4.1. Путь к данному бинарному файлу нужно передать при создании объекта класса RNNoise из данной обёртки (подробнее см. ниже).

Если вы используете Windows, то вам нужно вручную скомпилировать RNNoise. Вышеописанная инструкция не будет работать, воспользуйтесь данными ссылками: один, два. После компиляции путь к бинарному файлу нужно передать при создании объекта класса RNNoise из данной обёртки (подробнее см. ниже).

Использование
1. В коде Python
Подавление шума в аудиозаписи test.wav и сохранение результата как test_denoised.wav:

from rnnoise_wrapper import RNNoise

denoiser = RNNoise()

audio = denoiser.read_wav('test.wav')
denoised_audio = denoiser.filter(audio)
denoiser.write_wav('test_denoised.wav', denoised_audio)
Подавление шума в потоковом аудио (размер буфера равен 20 миллисекунд, т.е. 2 фрейма) (в примере используется имитация потока путём обработки аудиозаписи test.wav по частям с сохранением результата как test_denoised_stream.wav):

audio = denoiser.read_wav('test.wav')

denoised_audio = b''
buffer_size_ms = 20

for i in range(buffer_size_ms, len(audio), buffer_size_ms):
    denoised_audio += denoiser.filter(audio[i-buffer_size_ms:i].raw_data, sample_rate=audio.frame_rate)
if len(audio) % buffer_size_ms != 0:
    denoised_audio += denoiser.filter(audio[len(audio)-(len(audio)%buffer_size_ms):].raw_data, sample_rate=audio.frame_rate)

denoiser.write_wav('test_denoised_stream.wav', denoised_audio, sample_rate=audio.frame_rate)
Больше примеров работы с обёрткой можно найти в rnnoise_wrapper_functional_tests.py и rnnoise_wrapper_comparative_test.py.

Класс RNNoise содержит следующие методы:

read_wav(): принимает имя .wav аудиозаписи, приводит её в поддерживаемый формат (16 бит, моно) и возвращает объект pydub.AudioSegment с аудиозаписью
write_wav(): принимает имя .wav аудиозаписи, объект pydub.AudioSegment (или байтовую строку с аудиоданными без заголовков wav) и сохраняет аудиозапись под переданным именем
filter(): принимает объект pydub.AudioSegment (или байтовую строку с аудиоданными без заголовков wav), приводит его к частоте дискретизации 48000 Гц, разбивает аудиозапись на фреймы (длиной 10 миллисекунд), очищает их от шума и возвращает объект pydub.AudioSegment (или байтовую строку без заголовков wav) с сохранением исходной частоты дискретизации
filter_frame(): очистка только одного фрейма (длиной 10 мс, 16 бит, моно, 48000 Гц) от шума (обращение напрямую к бинарному файлу библиотеки RNNoise)
Подробная информация о поддерживаемых аргументах и работе каждого метода находится в комментариях в исходном коде этих методов.

По умолчанию используется модель librnnoise_5h_b_500k. При создании объекта класса RNNoise из обёртки с помощью аргумента f_name_lib можно указать другую модель (бинарник RNNoise):

librnnoise_5h_ru_500k или librnnoise_default для использования одной из комплектных моделей
полное/частичное имя/путь к скомпилированному бинарному файлу RNNoise
denoiser_def = RNNoise(f_name_lib='librnnoise_5h_ru_500k')
denoiser_new = RNNoise(f_name_lib='path/to/librnnoise.so.0.4.1')
Особенности основного метода filter():

для максимально качественной работы необходима аудиозапись длиной минимум 1 секунда, на которой присутсвует как голос, так и шум (причём шум в идеале должен быть до и после голоса). В противном случае качество шумоподавления будет хуже
в случае, если передаются части одной аудиозаписи (шумоподавление потоково аудио), то их длина должна быть не менее 10 мс и кратна 10 (т.к. библиотека RNNoise поддерживает только фреймы длиной 10 мс). Такой вариант работы на качество шумоподавления не влияет
если последний фрейм переданной аудиозаписи меньше 10 мс (или передана часть аудио длиной меньше 10 мс), то он дополняется нулями до необходимого размера. Из-за этого возможно небольшое увеличение длины итоговой аудиозаписи после шумоподавления
библиотека RNNoise дополнительно для каждого фрейма возвращает вероятность наличия голоса в этом фрейме (в виде числа от 0 до 1) и с помощью аргумента voice_prob_threshold можно отфильтровать фреймы по этому значению. Если вероятность ниже, чем voice_prob_threshold, то фрейм будет удалён из аудиозаписи
2. В качестве инструмента командной строки
python3 -m rnnoise_wrapper.cli -i input.wav -o output.wav
или

rnnoise_wrapper -i input.wav -o output.wav
Где: